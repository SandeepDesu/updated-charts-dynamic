import { IApiChartReturn, IApiSankeyReturn, IchartSingleton, IsankeyData } from "./chartSingleton";
import { Observable } from "rxjs/Observable";
/**
 * Base functionality for chart data builders.
 * This is where you format the data
 * The purpose of a builder is to transform the api return into usable structure for the component
 *
 */
export interface IbaseBuilder {
    /**
     * this is where the incoming API data is formatted for the component
     */
    formatData(): void;
    /**
     * calls the API and returns the API data object
     */
    getData(): Promise<null>;
    /**
     * the builder name - this later becomes the component name
     */
    getName(): string;
    /**
     * call this on destroy -  override to handle additional unsubscribes or event handlers
     */
    cleanup(): void;
    formattedData: any;
}
/**
 * base implementation for data builders.
 * override formatData to handle specific data structure changes from the API to the component
 */
export declare class BaseChartBuilder<T extends IchartSingleton> implements IbaseBuilder {
    formattedData: T[];
    dataSource: Observable<IApiChartReturn>;
    protected apireturn: IApiChartReturn;
    private sourceSubscription;
    protected datalevel: number;
    protected name: string;
    getData(): Promise<null>;
    /**
     * return data array from a given level in the data. level 0 is the same as getData()
     */
    getDataLevel(level: number): Promise<null>;
    /**
     * return the data array for a given level after the api return has happened
     */
    protected extractDataLevel(level: number, tempData: T[]): T[];
    /**
     * recursive function to combine details levels into one array
     */
    protected traversedatalevels(dataArr: T[], maxRecur: number): T[];
    /**
     * straight pass through, override to handle specific formatting
     */
    formatData(): void;
    formatTempData(tempData: T[]): void;
    getName(): string;
    constructor(name: string, level?: number);
    /**
     * unsubscribe from the source - always call this at the end
     */
    cleanup(): void;
}
export declare class SankeyBuilder implements IbaseBuilder {
    constructor(sourceData: any, name: any);
    formattedData: IsankeyData;
    dataSource: Observable<IApiSankeyReturn>;
    private apireturn;
    private sourceSubscription;
    protected name: string;
    getData(): Promise<null>;
    formatData(): void;
    getName(): string;
    cleanup(): void;
}
/**
 * pivots the data for x around grouping c.  also sums the y's and sets mins/maxes
 * every row will have a given x then any c's as a column with the corresponding y
 *
 * X        Y     C
 * purple   1     group1
 * purple   2     group2
 * orange   2     group1
 * orange   3     group2
 *
 * becomes:
 * X        total   group1  group2
 * purple   3       1       2
 * orange   5       2       3
 */
export declare class GroupedBuilder extends BaseChartBuilder<any> {
    constructor(sourceData: any, name: any, level?: number);
    YMax: number;
    YMin: number;
    YTotalMax: number;
    YTotalMin: number;
    formatData(): void;
}
export declare class WaterfallBuilder extends BaseChartBuilder<any> {
    constructor(sourceData: any, name: any, level?: number);
}
/**
 * straight passthrough object, no formatting, use IchartSingleton[] directly
 */
export declare class StandardBuilder extends BaseChartBuilder<any> {
    constructor(sourceData: any, name: any, level?: number);
}
/**
 * probably should remove this one
 * @deprecated Use StandardBuilder
 */
export declare class ChartBuilder extends BaseChartBuilder<IchartSingleton> {
    YLabel: string;
    XLabel: string;
    Barcolor: string;
    constructor(Xlabel: string, Ylabel: string, barcolor: string, name: string, level?: number);
    getCount(): number;
}
/**
 * Use this to build simple HTML tables from arrays of standard API output
 * builds an array of values from an array of IchartSingleton, or an array of values from any object or dictionary
 */
export declare class TableBuilder extends BaseChartBuilder<IchartSingleton> {
    protected HeaderArray: string[];
    constructor(data: any, headerArr: any, name: any, level?: number);
    formatData(): void;
    formatTempData(tempData: IchartSingleton[]): void;
    tableData(): void;
    getHeader(): string[];
    protected getRowsfromDict(indata: {}): any[];
    protected getRowsfromValuesArray(indata: IchartSingleton[]): any[];
}
